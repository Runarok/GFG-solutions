<h2><a href="https://www.geeksforgeeks.org/problems/quadratic-probing-in-hashing-1587115621/1?page=2&status=unsolved&sortBy=accuracy">Quadratic Probing in Hashing</a></h2><h3>Difficulty Level : Difficulty: Easy</h3><hr><div class="problems_problem_content__Xm_eO"><p><em><span style="font-size: 18px;">Quadratic probing is a collision handling technique in hashing. Quadratic probing says that whenever a collision occurs, search for i<sup>2</sup> position. </span></em></p>
<p><span style="font-size: 18px;">Given an array of integers and a Hash table. Fill the elements of the array into the hash table by using Quadratic Probing in case of collisions.</span></p>
<p><span style="font-size: 18px;"><strong>Examples : <br></strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input: </strong>hashSize = 11, n = 4, arr[] = {21,10,32,43}
<strong>Output: </strong>10 -1 -1 32 -1 -1 -1 -1 43 -1 21<strong>
Explanation: </strong>21%11=10 so 21 goes into hashTable[10] position, 10%11=10. HashTable[10] is already filled so we try for (10+1<sup>2</sup>)%11=0 position. HashTable[0] is empty so we put 10 there, 32%11=10. HashTable[10] is filled. We try (32+1<sup>2</sup>)%11=0, but HashTable[0] is also already filled, We try (32+2<sup>2</sup>)%11=3. HashTable[3] is empty so we put 32 in hashTable[3] position, 43 uses (43+3<sup>2</sup></span><span style="font-size: 18px;">)%11=8. We put it in hashTable[8].</span></pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong>hashSize = 11, n = 4, arr[] = {880,995,647,172 }
<strong>Output: </strong>880 -1 -1 -1 -1 995 -1 172 -1 647 -1&nbsp;<strong>
Explanation: </strong>Using the similar approach as used in above explanation we will get the output like 880 -1 -1 -1 -1 995 -1 172 -1 647 -1.</span>
</pre>
<pre><span style="font-size: 18px;"><strong>Input: </strong></span><span style="font-size: 18px;">hashSize = 11, </span><span style="font-size: 18px;">n = 4, </span><span style="font-size: 18px;">arr[] = {4,4,4,4} </span>
<span style="font-size: 18px;"><strong>Output: </strong>-1 -1 -1 -1 4 -1 -1 -1 -1 -1 -1 </span></pre>
<p><span style="font-size: 18px;"><strong>Your Task:</strong><br>You don't need to read input or print anything. Your task is to complete the function&nbsp;<strong>QuadraticProbing()&nbsp;</strong>which takes the hash table&nbsp;<strong>hash[]</strong>, the hash table size&nbsp;<strong>hashSize</strong>, an array&nbsp;<strong>arr[]&nbsp;</strong>and the size of the array <strong>n </strong>as inputs and inserts all the elements of the array arr[] into the hash table using Quadratic Probing as a collision handling technique.<br><br><strong>Note:&nbsp;</strong>You need to map duplicate elements incase, they have the same hash value even after quadratic probing.</span></p>
<p><span style="font-size: 18px;"><strong>Expected Time Complexity:&nbsp;</strong>O(n).<br><strong>Expected Auxiliary Space:&nbsp;</strong>O(1).</span></p>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br>2 &lt;= hashSize <strong>(prime)</strong> &lt;= 97<br>1 &lt;= n &lt; hashSize*0.5<br>0 &lt;= arr[] &lt;= 10<sup>5</sup></span></p>
<p><span style="font-size: 18px;"><strong>Note: </strong><br>All the positions that are unoccupied are denoted by -1 in the hash table.<br>An empty slot can only be found if <strong>load factor &lt; 0.5 </strong>and hash table size is a <strong>prime number</strong>.<br>The<strong> given testcases satisfy the above condition</strong> so you can <strong>assume </strong>that an empty slot is always reachable.</span></p>
<div id="professor_prebid-root"></div></div><br><p><span style=font-size:18px><strong>Topic Tags : </strong><br><code>Hash</code>&nbsp;<code>Data Structures</code>&nbsp;